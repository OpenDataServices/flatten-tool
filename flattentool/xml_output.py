from collections import OrderedDict
from warnings import warn

from flattentool.exceptions import (
    DataErrorWarning,
    FlattenToolError,
    FlattenToolWarning,
)
from flattentool.sort_xml import XMLSchemaWalker, sort_element

try:
    import lxml.etree as ET

    # If we're using lxml we have to do some extra work to support namespaces,
    # so we have a variable to check whether we're using lxml:
    USING_LXML = True
    # Note that lxml is now "required" - it's listed as a requirement in
    # setup.py and is needed for the tests to pass.
    # However, stdlib etree still exists as an unsupported feature.
except ImportError:
    import xml.etree.ElementTree as ET

    USING_LXML = False
    warn(
        "Using stdlib etree may work, but is not supported. Please install lxml.",
        FlattenToolWarning,
    )


def sort_attributes(data):
    attribs = []
    other = []
    for k, v in data.items():
        (other, attribs)[k.startswith("@")].append((k, v))
    return OrderedDict(sorted(attribs) + other)


def child_to_xml(child_elements, attrib, tagname, child, toplevel=False, nsmap=None):
    if hasattr(child, "items"):
        child_el = dict_to_xml(child, tagname, toplevel=False, nsmap=nsmap)
        if child_el is not None:
            child_elements.append(child_el)
    else:
        if tagname.startswith("@"):
            if USING_LXML and tagname.startswith("@xmlns"):
                nsname = tagname[1:].split(":", 1)[1]
                nsmap[nsname] = str(child)
                return
            try:
                attr_name = tagname[1:]
                if USING_LXML and ":" in attr_name:
                    attr_name = (
                        "{"
                        + nsmap.get(attr_name.split(":", 1)[0], "")
                        + "}"
                        + attr_name.split(":", 1)[1]
                    )
                attrib[attr_name] = str(child)
            except ValueError as e:
                warn(str(e), DataErrorWarning)
        elif tagname == "text()":
            return str(child)
        else:
            raise FlattenToolError("Everything should end with text() or an attribute!")
    return None


def dict_to_xml(data, tagname, toplevel=True, nsmap=None):
    if USING_LXML and ":" in tagname and not tagname.startswith("@xmlns"):
        tagname = (
            "{"
            + nsmap.get(tagname.split(":", 1)[0], "")
            + "}"
            + tagname.split(":", 1)[1]
        )

    if USING_LXML:
        data = sort_attributes(data)

    # We must create the child elements before their parent elements in order
    # to have the correct namespace information for the parent
    child_elements = []
    attrib = {}
    text = None

    for k, v in data.items():
        if type(v) == list:
            for item in v:
                t = child_to_xml(child_elements, attrib, k, item, nsmap=nsmap)
                if t:
                    text = t
        else:
            t = child_to_xml(
                child_elements, attrib, k, v, toplevel=toplevel, nsmap=nsmap
            )
            if t:
                text = t

    try:
        if USING_LXML:
            el = ET.Element(tagname, attrib=attrib, nsmap=nsmap)
        else:
            el = ET.Element(tagname, attrib=attrib)
    except ValueError as e:
        warn(str(e), DataErrorWarning)
        return

    for child_el in child_elements:
        el.append(child_el)
    if text:
        el.text = text

    return el


def toxml(
    data,
    xml_root_tag,
    xml_schemas=None,
    root_list_path="iati-activity",
    xml_comment=None,
):
    nsmap = {
        # This is "bound by definition" - see https://www.w3.org/XML/1998/namespace
        "xml": "http://www.w3.org/XML/1998/namespace"
    }
    root = dict_to_xml(data, xml_root_tag, nsmap=nsmap)
    if xml_schemas is not None:
        schema_dict = XMLSchemaWalker(xml_schemas).create_schema_dict(root_list_path)
        for element in root:
            sort_element(element, schema_dict)
    if xml_comment is None:
        xml_comment = "XML generated by flatten-tool"
    comment = ET.Comment(xml_comment)
    root.insert(0, comment)
    if USING_LXML:
        return ET.tostring(
            root, pretty_print=True, xml_declaration=True, encoding="utf-8"
        )
    else:
        return ET.tostring(root)
